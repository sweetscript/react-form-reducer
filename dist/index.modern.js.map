{"version":3,"file":"index.modern.js","sources":["../src/hooks/useFormErrors.ts","../src/hooks/useForm.ts","../src/contexts/FormContext.tsx","../src/hooks/useFormContext.ts","../src/types.ts"],"sourcesContent":["import { useState } from 'react';\nimport { Errors, FormErrorsProps } from '../types';\n\n/**\n * This hook can be used to easily handle returned validation errors\n */\nconst useFormErrors = (): FormErrorsProps => {\n  const [errors, setErrors] = useState<Errors>({});\n  const instance = {\n    errors: errors,\n\n    /**\n     * Determine if there are any error messages for the field\n     * @param field\n     */\n    has: (field: string) => {\n      return errors && !!Object.getOwnPropertyDescriptor(errors, field);\n    },\n\n    /**\n     * Determine if form has any errors\n     */\n    hasErrors: () => {\n      return Object.keys(errors).length > 0;\n    }\n  } as FormErrorsProps;\n\n  /**\n   * Returns an array of error messages for a field, or an empty array\n   * @param field\n   */\n  instance.get = (field: string) => {\n    return instance.has(field) ? errors[field] : [];\n  };\n  /**\n   * Returns the first error message for a field, false otherwise\n   */\n  instance.first = (field: string) => {\n    return instance.has(field) ? errors?.[field]?.[0] : false;\n  };\n\n  /**\n   * Get all error messages\n   */\n  instance.all = () => {\n    return errors;\n  };\n\n  //SETTERS\n  /**\n   * Add new error message for given field\n   * @param field\n   * @param message\n   */\n  instance.add = (field: string, message: string) => {\n    const newErrors: Errors = { ...errors };\n    if (!instance.has(field)) {\n      newErrors[field] = [];\n    }\n\n    if (newErrors[field].indexOf(message) === -1) {\n      newErrors[field].push(message);\n    }\n    setErrors(newErrors);\n  };\n\n  /**\n   * Set error messages\n   */\n  instance.set = (errors: Errors) => {\n    setErrors(errors);\n  };\n\n  /**\n   * Forget all the errors\n   */\n  instance.forget = (field?: string) => {\n    if (!field) {\n      if (instance.hasErrors()) setErrors({});\n    } else if (errors[field]) {\n      const res = { ...errors };\n      delete res[field];\n      setErrors(res);\n    }\n  };\n\n  return instance;\n};\n\nexport default useFormErrors;\n","import { ChangeEventHandler, useReducer, useState } from 'react';\nimport useFormErrors from './useFormErrors';\nimport { FormHookType, UseFormOptions } from '../types';\n\n/**\n * This is the form state hook\n * @param defaultValues\n * @param options\n */\nexport default function useForm<T>(\n  defaultValues: T,\n  options?: UseFormOptions<T>\n): FormHookType<T> {\n  const formErrors = useFormErrors();\n\n  const [isDirty, setIsDirty] = useState<boolean>(false);\n  const [isBusy, setIsBusy] = useState<boolean>(false);\n  const [step, setStep] = useState<number>(1);\n\n  const { onUpdateFields } = options || {};\n\n  // Fields state\n  const [fields, updateFields] = useReducer((prev: T, next: Partial<T>) => {\n    let newFields = { ...prev, ...next };\n    if (onUpdateFields) {\n      newFields = onUpdateFields(newFields);\n    }\n    return newFields;\n  }, defaultValues);\n\n  // Fields state setters\n  const setFields = (values: Partial<T>, setDirty = true) => {\n    if (onUpdateFields) {\n      values = onUpdateFields(values as T);\n    }\n    updateFields(values);\n    setIsDirty(setDirty);\n  };\n  const setField = (name: keyof T, value: unknown) => {\n    const v: { [key: string]: unknown } = {};\n    v[name as string] = value;\n    setFields(v as Partial<T>, true);\n\n    //Clear field error if present\n    formErrors.forget(name as string);\n  };\n  const handleInputChange =\n    (\n      name: keyof T\n    ): ChangeEventHandler<\n      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n    > =>\n    (event) => {\n      const target = event.currentTarget || event.target;\n      const targetType = target.getAttribute('type') || 'text';\n      if (['checkbox', 'radio'].indexOf(targetType) !== -1) {\n        setField(name, target instanceof HTMLInputElement && target.checked);\n      } else if (['number', 'range'].indexOf(targetType) !== -1) {\n        setField(name, Number(target.value));\n      } else {\n        setField(name, target.value);\n      }\n    };\n  const reset = () => {\n    setFields(defaultValues, false);\n  };\n\n  // Validation logic\n  const validate = async (fieldsToCheck?: Array<keyof T>) => {\n    const resolver = options?.validation;\n    if (!resolver) {\n      throw new Error('No validator resolver passed');\n    }\n    const valid = resolver.validate(fields, fieldsToCheck);\n    if (valid == true) {\n      return { passed: true };\n    }\n\n    formErrors.set(valid);\n    return { passed: false, error: valid };\n  };\n\n  return {\n    fields,\n    setFields,\n    setField,\n    handleInputChange,\n    reset,\n    errors: formErrors,\n    isDirty,\n    setIsDirty,\n    isBusy,\n    setIsBusy,\n    step,\n    setStep,\n    validate\n  };\n}\n","import React, { Context, createContext, ReactNode } from 'react';\nimport { FormContextType, UseFormOptions } from '../types';\nimport useForm from '../hooks/useForm';\n\nconst _FormContext = createContext<object>({});\n\nexport function FormContext<T>(): Context<FormContextType<T>> {\n  return _FormContext as Context<FormContextType<T>>;\n}\n\nexport function FormContextProvider<T>({\n  children,\n  defaultValues,\n  options\n}: {\n  children: ReactNode;\n  defaultValues: T;\n  options?: UseFormOptions<T>;\n}) {\n  const formInstance = useForm<T>(defaultValues, options);\n\n  const Context = FormContext<T>();\n\n  return <Context.Provider value={formInstance}>{children}</Context.Provider>;\n}\n","import { useContext } from 'react';\nimport { FormContext } from '../contexts/FormContext';\nimport { FormContextType } from '../types';\n\n/**\n * This hook can be used to easily share form state between child components, useful for stepped forms\n */\nexport default function useFormContext<T>() {\n  return useContext<FormContextType<T>>(FormContext<T>()) as FormContextType<T>;\n}\n","import React, { ChangeEventHandler } from 'react';\n\n// export interface FormHookType<R, M = never> {\nexport interface FormHookType<R> {\n  fields: R;\n  setFields: (fields: R) => void;\n  setField: (name: keyof R, value: unknown) => void;\n  handleInputChange: (\n    name: keyof R\n  ) => ChangeEventHandler<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n  >;\n  step: number;\n  setStep: React.Dispatch<React.SetStateAction<number>>;\n  isDirty: boolean;\n  setIsDirty: React.Dispatch<React.SetStateAction<boolean>>;\n  isBusy: boolean;\n  setIsBusy: React.Dispatch<React.SetStateAction<boolean>>;\n  reset: () => void;\n  errors: FormErrorsProps;\n\n  // Validation\n  validate: (fieldsToCheck?: Array<keyof R>) => Promise<FormValidateResponse>;\n\n  // meta: M;\n  // setAllMeta: (metaData: M) => void;\n  // setMeta: (name: keyof M, value: unknown) => void;\n}\n\nexport type FormContextType<R> = FormHookType<R>;\n\nexport type UseFormOptions<T> = {\n  onUpdateFields?: (fields: T) => T;\n\n  validation?: ValidationResolver<T>;\n};\n\nexport type FormValidateResponse = { passed: boolean; errors?: Errors };\n\nexport type Errors = { [key: string]: string[] };\n\nexport type FormErrorsProps = {\n  errors?: Errors;\n\n  //GETTERS\n  has: (field: string) => boolean;\n  hasErrors: () => boolean;\n  get: (field: string) => any;\n  first: (field: string) => string | false;\n  all: () => Errors;\n\n  //SETTERS\n  add: (field: string, message: string) => void;\n  set: (errors: Errors) => void;\n  forget: (field?: string) => void;\n};\n\nexport abstract class ValidationResolver<T> {\n  abstract validate(data: T, fieldsToCheck?: Array<keyof T>): true | Errors;\n}\n"],"names":["useFormErrors","errors","setErrors","useState","instance","has","field","Object","getOwnPropertyDescriptor","hasErrors","keys","length","_errors$field","message","newErrors","_extends","indexOf","push","res","defaultValues","options","formErrors","isDirty","setIsDirty","isBusy","setIsBusy","step","setStep","onUpdateFields","fields","updateFields","useReducer","prev","next","newFields","setFields","values","setDirty","setField","name","value","v","forget","handleInputChange","event","currentTarget","target","targetType","getAttribute","checked","Number","reset","validate","async","validation","resolver","Error","valid","fieldsToCheck","passed","set","error","_FormContext","createContext","FormContext","FormContextProvider","children","useForm","React","createElement","Context","Provider","formInstance","useFormContext","ValidationResolver"],"mappings":"2TAMMA,MAAAA,EAAgB,KACpB,MAAOC,EAAQC,GAAaC,EAAiB,CAAE,GACzCC,EAAW,CACfH,OAAQA,EAMRI,IAAMC,GACGL,KAAYM,OAAOC,yBAAyBP,EAAQK,GAM7DG,UAAW,IACIF,OAACG,KAAKT,GAAQU,OAAS,EAQxCP,IAAgBE,GACCF,EAACC,IAAIC,GAASL,EAAOK,GAAS,GAK/CF,MAAkBE,IAChB,IAAAM,EAAA,QAAeR,EAACC,IAAIC,KAASL,MAAAA,GAAA,OAAAA,EAAAA,EAASK,SAATL,EAAAW,EAAkB,GAAK,EAMtDR,IAAe,IACNH,EASTG,IAAe,CAACE,EAAeO,KAC7B,MAAeC,EAAAC,EAAA,CAAA,EAAgBd,GAC1BG,EAASC,IAAIC,KAChBQ,EAAUR,GAAS,KAGsB,IAAvCQ,EAAUR,GAAOU,QAAQH,IAC3BC,EAAUR,GAAOW,KAAKJ,GAExBX,EAAUY,EACZ,EAKAV,IAAgBH,IACdC,EAAUD,EAAM,EAMlBG,OAAmBE,IACjB,GAAKA,GAEE,GAAIL,EAAOK,GAAQ,CACxB,MAAMY,EAAWjB,EAAAA,GAAAA,UACPiB,EAACZ,GACXJ,EAAUgB,EACX,OALKd,EAASK,aAAaP,EAAU,CAAA,EAKrC,GAGH,OAAOE,GC7EK,WACZe,EACAC,GAEA,MAAgBC,EAAGrB,KAEZsB,EAASC,GAAcpB,GAAkB,IACzCqB,EAAQC,GAAatB,GAAkB,IACvCuB,EAAMC,GAAWxB,EAAiB,IAEnCyB,eAAEA,GAAmBR,GAAW,IAG/BS,EAAQC,GAAgBC,EAAW,CAACC,EAASC,KAClD,MAAqBD,EAAAA,GAAAA,EAASC,GAI9B,OAHIL,IACFM,EAAYN,EAAeM,OAG5Bf,GAGYgB,EAAG,CAACC,EAAoBC,GAAW,KAC5CT,IACFQ,EAASR,EAAeQ,IAE1BN,EAAaM,GACbb,EAAWc,IAEPC,EAAW,CAACC,EAAeC,KAC/B,MAAMC,EAAgC,CAAA,EACtCA,EAAEF,GAAkBC,EACpBL,EAAUM,GAAiB,GAG3BpB,EAAWqB,OAAOH,EACpB,EAqCA,MAAO,CACLV,SACAM,YACAG,WACAK,kBAtCEJ,GAIDK,IACC,QAAeA,EAAMC,eAAiBD,EAAME,OAC5BC,EAAGD,EAAOE,aAAa,SAAW,QACC,IAA/C,CAAC,WAAY,SAAShC,QAAQ+B,GAChCT,EAASC,EAAMO,+BAAsCA,EAAOG,UACN,IAA7C,CAAC,SAAU,SAASjC,QAAQ+B,GACrCT,EAASC,EAAMW,OAAOJ,EAAON,QAE7BF,EAASC,EAAMO,EAAON,MACvB,EA0BHW,MAxBY,KACZhB,EAAUhB,GAAe,EAAK,EAwB9BlB,OAAQoB,EACRC,UACAC,aACAC,SACAC,YACAC,OACAC,UACAyB,SA3BeC,UACf,cAAiBjC,SAAAA,EAASkC,WAC1B,IAAKC,EACH,MAAM,IAASC,MAAC,gCAElB,MAAMC,EAAQF,EAASH,SAASvB,EAAQ6B,GACxC,OAAa,GAATD,EACK,CAAEE,QAAQ,IAGnBtC,EAAWuC,IAAIH,GACR,CAAEE,QAAQ,EAAOE,MAAOJ,GAAK,EAkBxC,CC7FA,MAAkBK,eAAGC,EAAsB,CAAA,GAE3BC,SAAAA,IACd,OACFF,CAAA,CAEgBG,SAAAA,GAAuBC,SACrCA,EAAQ/C,cACRA,EAAaC,QACbA,IAMA,QAAqB+C,EAAWhD,EAAeC,KAE/B4C,iBAEhB,OAAOI,EAAAC,cAACC,EAAQC,SAAQ,CAAC/B,MAAOgC,GAAeN,EACjD,CCjBwBO,SAAAA,IACtB,SAAsCT,IACxC,OCgDwCU"}